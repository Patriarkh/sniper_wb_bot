import requests
import json
import asyncio
import settings
from telegram import Update
from telegram.ext import CommandHandler, MessageHandler, filters, ConversationHandler

# Стандартные стадии для диалога
SET_ITEMS, SET_DATE, SET_REVENUE = range(3)

# Стартовое сообщение
async def start(update: Update, context) -> None:
    await update.message.reply_text(
        "Привет! Я бот для работы с API mpstats. Давайте начнем с выбора количества товаров.\n"
        "Сколько товаров вы хотите получить? (например, 10)"
    )
    return SET_ITEMS

# Устанавливаем количество товаров
async def set_items(update: Update, context) -> int:
    count = update.message.text
    context.user_data['count'] = int(count)
    
    await update.message.reply_text(
        "Теперь укажите начальную дату в формате YYYY-MM-DD (например, 2024-09-18)."
    )
    return SET_DATE

# Устанавливаем дату
async def set_date(update: Update, context) -> int:
    date = update.message.text
    context.user_data['date'] = date
    
    await update.message.reply_text(
        "Укажите диапазон выручки. Напишите в формате: минимальная_выручка максимальная_выручка (например, 200000 1200000)"
    )
    return SET_REVENUE

# Устанавливаем выручку и отправляем запрос
async def set_revenue(update: Update, context) -> int:
    revenue_range = update.message.text.split()
    context.user_data['revenue_min'] = int(revenue_range[0])
    context.user_data['revenue_max'] = int(revenue_range[1])
    
    # Формирование данных для запроса
    json_data = {
        'startRow': 0,
        'endRow': context.user_data['count'],
        'filterModel': {
            'firstcommentdate': {
                'filterType': 'date',
                'type': 'greaterThan',
                'dateFrom': context.user_data['date'],
            },
            'revenue': {
                'filterType': 'number',
                'type': 'inRange',
                'filter': context.user_data['revenue_min'],
                'filterTo': context.user_data['revenue_max'],
            }
        }
    }
    
    url = 'https://mpstats.io/api/wb/get/category?path=Женщинам&d1=2024-09-09&d2=2024-10-08'
    headers = {
        'X-Mpstats-TOKEN': settings.MPSTATS_API_KEY,
        'Content-Type': 'application/json'
    }

    # Выполнение POST-запроса
    response = requests.post(url, headers=headers, data=json.dumps(json_data))
    
    if response.status_code == 200:
        data = response.json().get('data', [])
        if data:
            message = "Вот список товаров:\n"
            for item in data:
                name = item.get('name', 'Нет названия')
                revenue = item.get('revenue', 'Нет данных о выручке')
                first_comment_date = item.get('firstcommentdate', 'Нет данных о дате первого отзыва')
                message += f"Название товара: {name}, Выручка: {revenue}, Дата первого отзыва: {first_comment_date}\n"
            await update.message.reply_text(message)
        else:
            await update.message.reply_text("Не удалось найти товары по вашим параметрам.")
    else:
        await update.message.reply_text(f"Ошибка: {response.status_code}\n{response.text}")
    
    return ConversationHandler.END

# Команда для выхода
async def cancel(update: Update, context) -> None:
    await update.message.reply_text('Операция отменена.')
    return ConversationHandler.END

def main() -> None:
    # Создаем приложение
    application = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).build()
    
    # Определяем диалог
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            SET_ITEMS: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_items)],
            SET_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_date)],
            SET_REVENUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_revenue)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    
    application.add_handler(conv_handler)

   
    # Запускаем бота
    application.run_polling()
   

if __name__ == '__main__':
    main()
